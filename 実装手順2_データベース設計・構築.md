# データベース設計・構築 実装手順（初心者向け）

## 📚 このガイドについて

このガイドは、**2/4（水）: データベース設計・構築**の作業を初心者の方でも理解できるように、**用語の説明**や**各ステップの詳細**を丁寧に記載しています。

**所要時間**: 約3〜4時間（初めての場合）

---

## 📖 用語集（最初に読んでおくと理解が深まります）

### データベースに関する用語

- **テーブル**: データを整理して保存する表のようなもの。Excelのシートに似ています。
- **カラム（列）**: テーブルの縦の列。データの種類を表します（例: 名前、メールアドレス）。
- **行（レコード）**: テーブルの横の行。1件のデータを表します。
- **主キー（Primary Key）**: 各行を一意に識別するためのカラム。ID番号のようなものです。
- **外部キー（Foreign Key）**: 他のテーブルとの関連を表すカラム。別のテーブルの主キーを参照します。
- **リレーション（関連）**: テーブル同士の関係。例: 1人のユーザーが複数の予約を持つ（1対多）。
- **SQL**: データベースを操作するための言語。テーブルを作成したり、データを取得したりします。
- **RLS（Row Level Security）**: 行レベルセキュリティ。ユーザーが自分のデータだけを見られるようにする機能。

---

## 📋 今日（2/4）の作業内容

開発スケジュールの「2/4（水）: データベース設計・構築」を完了するためのステップバイステップガイドです。

**目標**: Supabaseにデータベーステーブルを作成し、テストデータを投入できる状態にする

---

## ✅ ステップ1: データベーススキーマの設計

### スキーマとは？

**スキーマ**: データベースの設計図です。どのテーブルを作るか、各テーブルにどんなカラムがあるかを定義します。

### 1-1. 全体像の理解

このプロジェクトでは、以下の8つのテーブルを作成します：

| テーブル名 | 説明 | 主な用途 |
|----------|------|----------|
| **users** | ユーザー情報 | LINEログインしたユーザーの情報を保存 |
| **applications** | 入会申込み | 入会申込みの内容を保存 |
| **practice_slots** | 練習枠 | 練習の日時と定員を保存 |
| **reservations** | 予約 | ユーザーが予約した練習を保存 |
| **payments** | 決済 | 月謝やイベント参加費の決済情報を保存 |
| **events** | イベント | イベント情報を保存 |
| **notifications** | 通知 | ユーザーへの通知を保存 |
| **admins** | 管理者 | 管理者の情報を保存 |

### 1-2. 各テーブルの詳細設計

#### テーブル1: users（ユーザー）

**目的**: LINEログインしたユーザーの情報を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | ユーザーID（一意） | 主キー、自動生成 |
| `line_user_id` | text | LINEユーザーID | ユニーク（重複不可） |
| `name` | text | 氏名 | 必須 |
| `email` | text | メールアドレス | 任意 |
| `phone` | text | 電話番号 | 任意 |
| `grade` | text | 学年 | 任意 |
| `profile_image` | text | プロフィール画像URL | 任意 |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |

**設計のポイント**:
- `id`は主キーとして、自動的にUUID（一意のID）が生成されます
- `line_user_id`はLINEログインで取得したIDを保存します

---

#### テーブル2: applications（入会申込み）

**目的**: 入会申込みの内容を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 申込みID | 主キー、自動生成 |
| `user_id` | uuid | ユーザーID | 外部キー（users.id参照） |
| `name` | text | 氏名 | 必須 |
| `name_kana` | text | フリガナ | 必須 |
| `grade` | text | 学年 | 必須 |
| `phone` | text | 電話番号 | 任意 |
| `email` | text | メールアドレス | 任意 |
| `parent_name` | text | 保護者氏名 | 任意 |
| `notes` | text | 備考 | 任意 |
| `status` | text | ステータス | 必須（pending/approved/rejected） |
| `rejected_reason` | text | 却下理由 | 任意 |
| `admin_memo` | text | 管理者メモ | 任意 |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |

**設計のポイント**:
- `user_id`は`users`テーブルの`id`を参照します（外部キー）
- `status`は「pending（未確認）」「approved（承認）」「rejected（却下）」のいずれかです

---

#### テーブル3: practice_slots（練習枠）

**目的**: 練習の日時と定員を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 練習枠ID | 主キー、自動生成 |
| `practice_date` | date | 練習日 | 必須 |
| `start_time` | time | 開始時間 | 必須 |
| `end_time` | time | 終了時間 | 必須 |
| `capacity` | integer | 定員 | 必須 |
| `current_reservations` | integer | 現在の予約数 | デフォルト0 |
| `status` | text | ステータス | 必須（open/full/closed/cancelled） |
| `notes` | text | 備考 | 任意 |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |

**設計のポイント**:
- `capacity`は定員数、`current_reservations`は現在の予約数を保存します
- `status`は「open（受付中）」「full（満席）」「closed（受付終了）」「cancelled（中止）」のいずれかです

---

#### テーブル4: reservations（予約）

**目的**: ユーザーが予約した練習を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 予約ID | 主キー、自動生成 |
| `user_id` | uuid | ユーザーID | 外部キー（users.id参照） |
| `practice_slot_id` | uuid | 練習枠ID | 外部キー（practice_slots.id参照） |
| `status` | text | ステータス | 必須（active/cancelled/completed） |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |
| `cancelled_at` | timestamptz | キャンセル日時 | 任意 |

**設計のポイント**:
- `user_id`と`practice_slot_id`の両方が外部キーです
- `status`は「active（予約中）」「cancelled（キャンセル済み）」「completed（参加済み）」のいずれかです

---

#### テーブル5: payments（決済）

**目的**: 月謝やイベント参加費の決済情報を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 決済ID | 主キー、自動生成 |
| `user_id` | uuid | ユーザーID | 外部キー（users.id参照） |
| `type` | text | 決済種別 | 必須（monthly_fee/event_fee） |
| `amount` | numeric | 金額 | 必須 |
| `status` | text | ステータス | 必須（pending/completed/failed/refunded） |
| `payment_service_id` | text | 決済サービスID（Stripeなど） | 任意 |
| `event_id` | uuid | イベントID（イベント参加費の場合） | 任意 |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |
| `paid_at` | timestamptz | 決済日時 | 任意 |

**設計のポイント**:
- `type`は「monthly_fee（月謝）」「event_fee（イベント参加費）」のいずれかです
- `status`は「pending（未決済）」「completed（決済完了）」「failed（決済失敗）」「refunded（返金済み）」のいずれかです

---

#### テーブル6: events（イベント）

**目的**: イベント情報を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | イベントID | 主キー、自動生成 |
| `title` | text | イベント名 | 必須 |
| `event_date` | date | 開催日 | 必須 |
| `start_time` | time | 開始時間 | 必須 |
| `end_time` | time | 終了時間 | 必須 |
| `location` | text | 開催場所 | 任意 |
| `target_grade` | text | 対象学年 | 任意 |
| `capacity` | integer | 定員 | 任意 |
| `fee` | numeric | 参加費 | デフォルト0 |
| `deadline` | timestamptz | 申込締切 | 任意 |
| `description` | text | イベント詳細 | 任意 |
| `is_published` | boolean | 公開ステータス | デフォルトfalse |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |

**設計のポイント**:
- `is_published`が`true`のイベントのみ会員に表示されます
- `fee`が0の場合は無料イベントです

---

#### テーブル7: notifications（通知）

**目的**: ユーザーへの通知を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 通知ID | 主キー、自動生成 |
| `user_id` | uuid | ユーザーID | 外部キー（users.id参照） |
| `type` | text | 通知種別 | 必須 |
| `title` | text | タイトル | 必須 |
| `content` | text | 本文 | 必須 |
| `is_read` | boolean | 既読フラグ | デフォルトfalse |
| `created_at` | timestamptz | 作成日時 | 自動設定 |

**設計のポイント**:
- `is_read`が`false`の通知は未読として表示されます
- `type`は「application_status」「event」「payment」「reservation」などです

---

#### テーブル8: admins（管理者）

**目的**: 管理者の情報を保存します。

| カラム名 | データ型 | 説明 | 制約 |
|---------|---------|------|------|
| `id` | uuid | 管理者ID | 主キー、自動生成 |
| `email` | text | メールアドレス | 必須、ユニーク |
| `password_hash` | text | パスワードハッシュ | 必須 |
| `name` | text | 管理者名 | 必須 |
| `created_at` | timestamptz | 作成日時 | 自動設定 |
| `updated_at` | timestamptz | 更新日時 | 自動更新 |

**設計のポイント**:
- `password_hash`にはパスワードをハッシュ化した値を保存します（平文は保存しません）
- `email`はユニーク（重複不可）です

---

### 1-3. リレーション（関連）の定義

テーブル同士の関係を定義します：

| 関係 | 説明 | 外部キー |
|------|------|----------|
| **users → applications** | 1人のユーザーが複数の入会申込みを持つ | `applications.user_id` → `users.id` |
| **users → reservations** | 1人のユーザーが複数の予約を持つ | `reservations.user_id` → `users.id` |
| **users → payments** | 1人のユーザーが複数の決済を持つ | `payments.user_id` → `users.id` |
| **users → notifications** | 1人のユーザーが複数の通知を持つ | `notifications.user_id` → `users.id` |
| **practice_slots → reservations** | 1つの練習枠に複数の予約がある | `reservations.practice_slot_id` → `practice_slots.id` |

**リレーションの説明**:
- **1対多**: 1人のユーザーが複数の予約を持つような関係
- **外部キー**: 別のテーブルの主キーを参照するカラム

---

## ✅ ステップ2: Supabaseでのテーブル作成

### 2-1. Supabase Dashboardを開く

**手順**:

1. **Supabase Dashboardにアクセス**
   - https://supabase.com/dashboard にアクセス
   - 作成したプロジェクトを選択

2. **SQL Editorを開く**
   - 左側のメニューから「SQL Editor」をクリック
   - 「New query」をクリックして新しいクエリを作成

---

### 2-2. テーブル作成SQLの準備

以下のSQLをコピーして、SupabaseのSQL Editorに貼り付けます。

**⚠️ 重要**: テーブルは順番に作成する必要があります。外部キー制約があるため、参照先のテーブルを先に作成します。

**作成順序**:
1. users（他のテーブルから参照される）
2. applications
3. practice_slots
4. reservations（usersとpractice_slotsの両方を参照）
5. payments
6. events
7. notifications
8. admins

---

### 2-3. テーブル作成SQLの実行

#### ステップ1: usersテーブルの作成

SQL Editorに以下のSQLを貼り付けて実行します：

```sql
-- usersテーブルの作成
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  line_user_id TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  email TEXT,
  phone TEXT,
  grade TEXT,
  profile_image TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- updated_atを自動更新する関数を作成
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- usersテーブルのupdated_atを自動更新するトリガーを作成
CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成（検索を高速化）
CREATE INDEX idx_users_line_user_id ON users(line_user_id);
```

**実行方法**:
1. SQL Editorに上記のSQLを貼り付け
2. 「Run」ボタンをクリック（または `Ctrl + Enter`）
3. 「Success. No rows returned」と表示されれば成功

---

#### ステップ2: applicationsテーブルの作成

```sql
-- applicationsテーブルの作成
CREATE TABLE applications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  name_kana TEXT NOT NULL,
  grade TEXT NOT NULL,
  phone TEXT,
  email TEXT,
  parent_name TEXT,
  notes TEXT,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  rejected_reason TEXT,
  admin_memo TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_applications_updated_at
  BEFORE UPDATE ON applications
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_applications_user_id ON applications(user_id);
CREATE INDEX idx_applications_status ON applications(status);
```

**ポイント**:
- `REFERENCES users(id)` で外部キー制約を設定
- `ON DELETE CASCADE` でユーザーが削除されたら申込みも削除
- `CHECK` でstatusの値を制限

---

#### ステップ3: practice_slotsテーブルの作成

```sql
-- practice_slotsテーブルの作成
CREATE TABLE practice_slots (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  practice_date DATE NOT NULL,
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  capacity INTEGER NOT NULL,
  current_reservations INTEGER DEFAULT 0,
  status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'full', 'closed', 'cancelled')),
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_practice_slots_updated_at
  BEFORE UPDATE ON practice_slots
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_practice_slots_date ON practice_slots(practice_date);
CREATE INDEX idx_practice_slots_status ON practice_slots(status);
```

---

#### ステップ4: reservationsテーブルの作成

```sql
-- reservationsテーブルの作成
CREATE TABLE reservations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  practice_slot_id UUID NOT NULL REFERENCES practice_slots(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'cancelled', 'completed')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  cancelled_at TIMESTAMPTZ
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_reservations_updated_at
  BEFORE UPDATE ON reservations
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_reservations_user_id ON reservations(user_id);
CREATE INDEX idx_reservations_practice_slot_id ON reservations(practice_slot_id);
CREATE INDEX idx_reservations_status ON reservations(status);

-- 1人のユーザーが同じ練習枠に複数予約できないようにする制約
CREATE UNIQUE INDEX idx_reservations_user_slot_unique 
  ON reservations(user_id, practice_slot_id) 
  WHERE status = 'active';
```

**ポイント**:
- `UNIQUE INDEX` で1人のユーザーが同じ練習枠に複数予約できないように制限
- `WHERE status = 'active'` でキャンセル済みの予約は除外

---

#### ステップ5: paymentsテーブルの作成

```sql
-- paymentsテーブルの作成
CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('monthly_fee', 'event_fee')),
  amount NUMERIC NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'completed', 'failed', 'refunded')),
  payment_service_id TEXT,
  event_id UUID,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  paid_at TIMESTAMPTZ
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_payments_updated_at
  BEFORE UPDATE ON payments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_payments_user_id ON payments(user_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_payments_type ON payments(type);
```

---

#### ステップ6: eventsテーブルの作成

```sql
-- eventsテーブルの作成
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  event_date DATE NOT NULL,
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  location TEXT,
  target_grade TEXT,
  capacity INTEGER,
  fee NUMERIC DEFAULT 0,
  deadline TIMESTAMPTZ,
  description TEXT,
  is_published BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_events_updated_at
  BEFORE UPDATE ON events
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_events_date ON events(event_date);
CREATE INDEX idx_events_published ON events(is_published);
```

---

#### ステップ7: notificationsテーブルの作成

```sql
-- notificationsテーブルの作成
CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  is_read BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- インデックスの作成
CREATE INDEX idx_notifications_user_id ON notifications(user_id);
CREATE INDEX idx_notifications_is_read ON notifications(is_read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at DESC);
```

---

#### ステップ8: adminsテーブルの作成

```sql
-- adminsテーブルの作成
CREATE TABLE admins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- updated_atを自動更新するトリガー
CREATE TRIGGER update_admins_updated_at
  BEFORE UPDATE ON admins
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- インデックスの作成
CREATE INDEX idx_admins_email ON admins(email);
```

---

### 2-4. テーブル作成の確認

**手順**:

1. **Table Editorで確認**
   - 左側のメニューから「Table Editor」をクリック
   - 作成した8つのテーブルが表示されれば成功

2. **各テーブルの構造を確認**
   - テーブル名をクリックして、カラムが正しく作成されているか確認

---

## ✅ ステップ3: Row Level Security (RLS) ポリシーの設定

### 3-1. RLSとは？

**Row Level Security (RLS)**: データベースレベルでのセキュリティ機能です。ユーザーが自分のデータだけを見られるようにします。

**なぜ必要？**: 
- ユーザーAがユーザーBのデータを見られないようにする
- 管理者だけが全データを見られるようにする

---

### 3-2. RLSの有効化

各テーブルでRLSを有効化します。SQL Editorで以下を実行：

```sql
-- すべてのテーブルでRLSを有効化
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE applications ENABLE ROW LEVEL SECURITY;
ALTER TABLE practice_slots ENABLE ROW LEVEL SECURITY;
ALTER TABLE reservations ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE admins ENABLE ROW LEVEL SECURITY;
```

---

### 3-3. 基本的なポリシーの設定

#### usersテーブルのポリシー

```sql
-- ユーザーは自分のデータのみ閲覧可能
CREATE POLICY "Users can view own data"
  ON users FOR SELECT
  USING (auth.uid()::text = id::text);

-- ユーザーは自分のデータのみ更新可能
CREATE POLICY "Users can update own data"
  ON users FOR UPDATE
  USING (auth.uid()::text = id::text);
```

**注意**: このポリシーはSupabase Authを使用する場合の例です。LINEログインを使用する場合は、後でカスタムポリシーを設定します。

---

#### applicationsテーブルのポリシー

```sql
-- ユーザーは自分の申込みのみ閲覧可能
CREATE POLICY "Users can view own applications"
  ON applications FOR SELECT
  USING (auth.uid()::text = user_id::text);

-- ユーザーは自分の申込みを作成可能
CREATE POLICY "Users can create own applications"
  ON applications FOR INSERT
  WITH CHECK (auth.uid()::text = user_id::text);
```

---

#### reservationsテーブルのポリシー

```sql
-- ユーザーは自分の予約のみ閲覧可能
CREATE POLICY "Users can view own reservations"
  ON reservations FOR SELECT
  USING (auth.uid()::text = user_id::text);

-- ユーザーは自分の予約を作成可能
CREATE POLICY "Users can create own reservations"
  ON reservations FOR INSERT
  WITH CHECK (auth.uid()::text = user_id::text);

-- ユーザーは自分の予約を更新可能
CREATE POLICY "Users can update own reservations"
  ON reservations FOR UPDATE
  USING (auth.uid()::text = user_id::text);
```

---

#### notificationsテーブルのポリシー

```sql
-- ユーザーは自分の通知のみ閲覧可能
CREATE POLICY "Users can view own notifications"
  ON notifications FOR SELECT
  USING (auth.uid()::text = user_id::text);

-- ユーザーは自分の通知を更新可能（既読にする）
CREATE POLICY "Users can update own notifications"
  ON notifications FOR UPDATE
  USING (auth.uid()::text = user_id::text);
```

---

#### practice_slotsテーブルのポリシー

```sql
-- すべてのユーザーが練習枠を閲覧可能（認証不要）
CREATE POLICY "Anyone can view practice slots"
  ON practice_slots FOR SELECT
  USING (true);
```

---

#### eventsテーブルのポリシー

```sql
-- 公開されているイベントのみ閲覧可能（認証不要）
CREATE POLICY "Anyone can view published events"
  ON events FOR SELECT
  USING (is_published = true);
```

---

#### paymentsテーブルのポリシー

```sql
-- ユーザーは自分の決済履歴のみ閲覧可能
CREATE POLICY "Users can view own payments"
  ON payments FOR SELECT
  USING (auth.uid()::text = user_id::text);
```

---

**⚠️ 注意**: 上記のポリシーはSupabase Authを使用する場合の例です。LINEログインを使用する場合は、認証方法に応じてポリシーを調整する必要があります。開発初期は、RLSを無効化して開発を進めることも可能です。

---

## ✅ ステップ4: シードデータの作成（テスト用）

### 4-1. シードデータとは？

**シードデータ**: テスト用の初期データです。開発中に動作確認するために使用します。

---

### 4-2. テスト用ユーザーの作成

```sql
-- テスト用ユーザーの作成
INSERT INTO users (line_user_id, name, email, phone, grade)
VALUES 
  ('test_line_user_001', '山田太郎', 'yamada@example.com', '090-1234-5678', '小学3年生'),
  ('test_line_user_002', '佐藤花子', 'sato@example.com', '090-2345-6789', '小学4年生'),
  ('test_line_user_003', '鈴木一郎', 'suzuki@example.com', '090-3456-7890', '小学5年生');
```

---

### 4-3. テスト用練習枠の作成

```sql
-- テスト用練習枠の作成
INSERT INTO practice_slots (practice_date, start_time, end_time, capacity, status)
VALUES 
  ('2024-02-10', '17:00', '18:30', 10, 'open'),
  ('2024-02-10', '19:00', '20:30', 10, 'open'),
  ('2024-02-12', '17:00', '18:30', 10, 'open'),
  ('2024-02-12', '19:00', '20:30', 10, 'full'),
  ('2024-02-14', '17:00', '18:30', 10, 'closed');
```

---

### 4-4. テスト用イベントの作成

```sql
-- テスト用イベントの作成
INSERT INTO events (title, event_date, start_time, end_time, location, target_grade, capacity, fee, is_published)
VALUES 
  ('春のサッカー大会', '2024-03-15', '10:00', '15:00', 'グラウンドA', '全学年', 50, 1000, true),
  ('サッカー教室説明会', '2024-03-20', '14:00', '16:00', '教室', '新規入会希望者', 30, 0, true),
  ('夏合宿', '2024-07-20', '09:00', '17:00', '合宿所', '小学4年生以上', 20, 5000, false);
```

---

### 4-5. テスト用管理者の作成

```sql
-- テスト用管理者の作成（パスワードは後でハッシュ化する必要があります）
-- 注意: 実際のパスワードはハッシュ化して保存してください
INSERT INTO admins (email, password_hash, name)
VALUES 
  ('admin@example.com', '$2a$10$example_hash_here', '管理者太郎');
```

**⚠️ 重要**: 実際のパスワードはハッシュ化して保存してください。開発環境では簡単なパスワードでも構いませんが、本番環境では必ず強力なパスワードを使用してください。

---

## ✅ ステップ5: 動作確認

### 5-1. テーブルの確認

1. **Table Editorで確認**
   - Supabase Dashboard > Table Editor
   - 各テーブルをクリックして、データが正しく作成されているか確認

2. **SQL Editorで確認**
   ```sql
   -- ユーザー数を確認
   SELECT COUNT(*) FROM users;
   
   -- 練習枠を確認
   SELECT * FROM practice_slots ORDER BY practice_date;
   
   -- イベントを確認
   SELECT * FROM events WHERE is_published = true;
   ```

---

### 5-2. リレーションの確認

```sql
-- ユーザーと予約のリレーションを確認
SELECT 
  u.name AS user_name,
  ps.practice_date,
  ps.start_time,
  r.status AS reservation_status
FROM users u
JOIN reservations r ON u.id = r.user_id
JOIN practice_slots ps ON r.practice_slot_id = ps.id;
```

---

## ✅ 完了チェックリスト

以下の項目を確認して、すべて完了したらデータベース設計・構築が完了です！

- [ ] 8つのテーブルがすべて作成されている
- [ ] 外部キー制約が正しく設定されている
- [ ] インデックスが作成されている
- [ ] RLSが有効化されている
- [ ] 基本的なポリシーが設定されている
- [ ] テスト用のシードデータが投入されている
- [ ] 動作確認が完了している

---

## 📝 次のステップ

次回（2/5）の作業内容：
- LINE Developers の設定
- NextAuth.js の導入
- LINEログインの基本設定

詳細は `開発スケジュール.md` を参照してください。

---

## ⚠️ トラブルシューティング

### エラー1: 外部キー制約エラー

**エラーメッセージ例**:
```
ERROR: insert or update on table "applications" violates foreign key constraint
```

**原因**: 参照先のテーブル（users）が存在しない、または参照するIDが存在しません。

**解決方法**:
- テーブルを正しい順序で作成してください（users → applications）
- シードデータを投入する際は、参照先のデータが存在することを確認してください

---

### エラー2: ユニーク制約エラー

**エラーメッセージ例**:
```
ERROR: duplicate key value violates unique constraint
```

**原因**: ユニーク制約があるカラムに重複した値を挿入しようとしています。

**解決方法**:
- `line_user_id`や`email`など、ユニーク制約があるカラムの値を確認してください
- 重複しない値を使用してください

---

### エラー3: CHECK制約エラー

**エラーメッセージ例**:
```
ERROR: new row for relation "applications" violates check constraint
```

**原因**: CHECK制約で許可されていない値を挿入しようとしています。

**解決方法**:
- `status`などの値が、定義したCHECK制約の値（例: 'pending', 'approved', 'rejected'）に含まれているか確認してください

---

## 💡 よくある質問（FAQ）

### Q1: テーブルを削除したい場合は？

**A**: SQL Editorで以下を実行：
```sql
DROP TABLE IF EXISTS テーブル名 CASCADE;
```
`CASCADE`を付けると、そのテーブルを参照している他のテーブルも一緒に削除されます。

---

### Q2: カラムを追加したい場合は？

**A**: SQL Editorで以下を実行：
```sql
ALTER TABLE テーブル名 ADD COLUMN カラム名 データ型;
```

---

### Q3: データを全削除したい場合は？

**A**: SQL Editorで以下を実行：
```sql
TRUNCATE TABLE テーブル名 CASCADE;
```
⚠️ **注意**: データが完全に削除されます。実行前に確認してください。

---

**最終更新**: 2024年2月4日  
**対象**: プログラミング初心者の方
